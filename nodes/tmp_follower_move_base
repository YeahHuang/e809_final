#!/usr/bin/env python


import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal

from geometry_msgs.msg import PoseStamped, Twist, Point, Vector3
from tf import TransformListener, TransformBroadcaster
from tf.transformations import euler_from_quaternion
import tf
import sys
import yaml, numpy
import math
from actionlib_msgs.msg import *

from fiducial_msgs.msg import Fiducial, FiducialTransform, FiducialTransformArray

from geometry_msgs.msg import PoseWithCovarianceStamped, TransformStamped

def get_goals_from_yaml():
    """Get goals from data stored in location_recorder.yaml"""

    # Get the current directory (e.g. /home/xxx/catkin_ws/src/location_recorder/nodes)
    ws_path = sys.path[0]

    # Get the path to save location_recorder.yaml
    recorder_path = ws_path + "/../yaml/location_recorder.yaml"
    with open(recorder_path, 'r') as yaml_file:
        rec = yaml.safe_load_all(yaml_file)
        # Transforming rec to list could solve the error:
        #      TypeError: 'generator' object has no attribute '__getitem__'
        goals = [goal for goal in rec]
        print("Returning record for updating self.goals", goals)
    return goals


# def movebase_client():
#     client = actionlib.SimpleActionClient('/leader/move_base', MoveBaseAction)
#     client.wait_for_server()
#
#     goal = MoveBaseGoal()
#     goal.target_pose.header.frame_id = "map"
#     goal.target_pose.header.stamp = rospy.Time.now()
#     # goal.target_pose.pose.position.x = 8.56
#     # goal.target_pose.pose.position.y = 1.27
#     goal.target_pose.pose.position.x = -7
#     goal.target_pose.pose.position.y = 3
#     goal.target_pose.pose.orientation.w = 1.0
#
#     client.send_goal(goal)
#     wait = client.wait_for_result()
#     if not wait:
#         rospy.logerr("Action server not available!")
#         rospy.signal_shutdown("Action server not available!")
#     else:
#         return client.get_result()


# def publish_on_move_base():
#     # Create a publisher
#     pub = rospy.Publisher("/leader/move_base_simple/goal", PoseStamped, queue_size=10)
#     # Create a message of type PoseStamped
#     message = PoseStamped()
#     # Build your message
#     message.header.frame_id = "map"
#     message.header.stamp = rospy.Time.now()
#     message.pose.position.x = -7
#     message.pose.position.y = 3
#     message.pose.position.z = 0
#     message.pose.orientation.w = 1
#
#     rate = rospy.Rate(1)
#
#     while not rospy.is_shutdown():
#         pub.publish(message)
#         rate.sleep()


class FiducialBroadcast:

    def __init__(self):
        print("Initializing new FiducialBroadcast object ")
        rospy.init_node('fiducial_broadcast')
        self.br = TransformBroadcaster()
        rospy.Subscriber('/fiducial_transforms', FiducialTransformArray, self.newTf)

        # rospy.Subscriber("/follower/amcl_pose", PoseWithCovarianceStamped, self.get_rotation)
        self.rate = rospy.Rate(10)
        # self.posePub = rospy.Publisher("/fiducial_pose", PoseWithCovarianceStamped, queue_size=1)
        self.child_frame = "marker_frame"  # Name suggested by professor, could be any name
        self.parent_frame = "follower_tf/camera_rgb_optical_frame"
        self.translation = None
        self.rotation = None

        # Assume the follower is not in exploration_mode
        self.exploration_mode = False

        # set up a tf listener to retrieve transform between the robot and the world
        self.tf_listener = TransformListener()

        # initialize the position&orientation of goals with data retrieved from yaml
        self.goals = get_goals_from_yaml()
        # initialize the status of whether the current goal is reached to be False(unreached)
        self.goalReached = False
        # initialize the 1st goal to reach be 0
        # currentGoalId: 0-livingroom 1-recreationroom 2-kitchen 3-bedroom
        self.currentGoalId = 0

        self.goal = MoveBaseGoal()
        # set up the frame parameters
        self.goal.target_pose.header.frame_id = "map"
        self.goal.target_pose.pose.orientation.x = 0
        self.goal.target_pose.pose.orientation.y = 0
        self.goal.target_pose.pose.orientation.z = 0
        self.goal.target_pose.pose.orientation.w = 1
        # self.follower_pos = None
        # self.follower_ori = None
        # self.follower_pose = PoseStamped()
        # self.follower_pose.header.frame_id = 'map'
        # self.follower_pose.header.stamp = rospy.Time.now()
        # self.follower_pose.pose.position.x = 2.2400196
        # self.follower_pose.pose.position.y = 0.8411427
        # self.follower_pose.pose.position.z = 0.0
        # self.follower_pose.pose.orientation.x = 0.0
        # self.follower_pose.pose.orientation.y = 0.0
        # self.follower_pose.pose.orientation.z = 0.0
        # self.follower_pose.pose.orientation.w = 1.0

#     def get_rotation(self, msg):
#         """
#         :param msg: message received from amcl_pose
#         :return null
#         Update the global variable pos, ori with current amcl_pose
#         """
#         print("In get_rotation")
#         (self.follower_pos, self.follower_ori) = (msg.pose.pose.position, msg.pose.pose.orientation)
#         self.follower_pose = msg.pose.pose
#         rospy.loginfo("Updating amcl pos={p}, ori={o}".format(p=self.follower_pos, o=self.follower_ori))
#         """
#         Updating amcl pos=x: 2.24612911149
# y: 0.850341687014
# z: 0.0, ori=x: 0.0
# y: 0.0
# z: -0.00394561706391
# w: 0.999992216023
#
#         """

    def publishTransform(self):

        """publish the transform when self.translation and self.rotation is not None
        """

        if self.translation and self.rotation:
            # The publishLock is optional here. I choose to comment it for now
            # self.publishLock.acquire()
            # print(self.translation, self.rotation)
            self.br.sendTransform(self.translation,
                                  self.rotation,
                                  rospy.Time.now(),  # !!! Not sure whether it should be msg.header.stamp
                                  # Tutorial2 shows rospy.Time.now() vs tutorial3 shows the latter
                                  self.child_frame,
                                  self.parent_frame)
            self.rate.sleep()
            # self.publishLock.release()

    def within_range(self, pos1, pos2):
        return pos1 and pos2 and math.sqrt((pos2[0]-pos1[0])**2 + (pos2[1]-pos1[1])**2) < 0.5

    def newTf_test(self, msg):
        for t in msg.transforms:  # len(msg.transforms) always equals 1 in our case
            tr = t.transform.translation
            rot = t.transform.rotation
            # tr.z = 0  # hardcode the marker's z to be 0, otherwise the follower could never reach it
            self.translation = (tr.x, tr.y, tr.z)
            self.rotation = (rot.x, rot.y, rot.z, rot.w)

            # When the marker is out of range(0.5m) of the follower
            self.publishTransform()
            self.rate.sleep()
            self.get_marker_data_test()

    def get_marker_data_test(self):
        t = self.tf_listener.getLatestCommonTime("/map","/marker_frame")
        position, quaterion = self.tf_listener.lookupTransform( "/map", "/marker_frame",t)
        print(position, quaterion)
        pos, ori = self.tf_listener.lookupTransform("/map","/follower_tf/base_link", t)
        print(pos)

    def newTf(self, msg):
        """
            Broadcast fiducial_transforms when a FiducialTransformArray is received

            The tutorial followed when writing this function:
            1. Write broadcaster in Python
                http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28Python%29
            2. Write broadcaster in C++(suggested by prof)
                http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28C%2B%2B%2
            3. fiducial's github:
                https://github.com/jrlandau/fiducials-1/blob/master/fiducial_slam/src/fiducial_slam.py#L173
        """

        print("In newTf")
        if msg.transforms:  # When the marker is found
            if self.exploration_mode:  # When in exploration mode
                rospy.loginfo("Marker found")
            for t in msg.transforms:  # len(msg.transforms) always equals 1 in our case
                                        # type(t is geometry_msgs/Transform
                tr = t.transform.translation
                rot = t.transform.rotation
                # tr.z = 0  # hardcode the marker's z to be 0, otherwise the follower could never reach it
                self.translation = (tr.x, tr.y, tr.z)
                self.rotation = (rot.x, rot.y, rot.z, rot.w)
                self.publishTransform()
                self.rate.sleep()
                pos_marker, ori_marker, pos_follower = self.get_marker_data()

                # print(self.follower_pos, self.goal.target_pose.pose.position)
                if not self.within_range(pos_marker, pos_follower):
                    # When the marker is out of range(0.5m) of the follower
                    self.update_goal_with_marker(pos_marker, ori_marker)
                    self.move_to_goal()
                    if self.exploration_mode:
                        rospy.loginfo("Following")
                else:
                    # When the marker is within 0.5m of the follower, do nothing
                    print(pos_marker, self.goal.target_pose.pose.position, "Do nothing")
                    pass
            self.exploration_mode = False
        else:
            rospy.loginfo("Looking for marker")
            self.exploration_mode = True

            self.currentGoalId = rospy.get_param("currentGoalId")
            self.update_goal_with_yaml_data()
            self.move_to_goal()

    # For step 3 listener.lookupTransform
    def get_marker_data(self):
        """Get the current position, orientation of marker_frame in /map frame

        Return
        ----------
        The position (x, y, z) and the orientation(x,y,z,w) of the marker
        The posision (x, y, z) of the follower
        """

        t = self.tf_listener.getLatestCommonTime("/map","/marker_frame")
        pos_marker, ori_marker = self.tf_listener.lookupTransform( "/map", "/marker_frame",t)
        pos_follower, _ = self.tf_listener.lookupTransform("/map","/follower_tf/base_link", t)
        return pos_marker, ori_marker, pos_follower


    def update_goal_with_marker(self, pos, ori):
        """
        :param pos: position of marker_frame, looks like [2.982819443974907, 0.8586162820460231, 0.3045994670744631]
        :param ori: orientation of marker_frame, looks like [-0.5109184755511623, 0.4943752129364844, 0.4886555454181498, -0.5057382901329233])
        :return:
        """
        self.goal.target_pose.header.stamp = rospy.Time.now()
        self.goal.target_pose.pose.position.x = pos[0] - 0.3
        self.goal.target_pose.pose.position.y = pos[1] - 0.3
        self.goal.target_pose.pose.position.z = 0 # hardcode z to be 0 otherwise the follower could never reach

        # self.goal.target_pose.pose.orientation.x = 0
        # self.goal.target_pose.pose.orientation.y = 0
        # self.goal.target_pose.pose.orientation.z = 0
        # self.goal.target_pose.pose.orientation.w = 1

    def update_goal_with_yaml_data(self):

        self.goal.target_pose.header.stamp = rospy.Time.now()

        # moving towards the goal*/
        pos = self.goals[self.currentGoalId].values()[0]["position"]
        ori = self.goals[self.currentGoalId].values()[0]["orientation"]

        self.goal.target_pose.pose.position.x = pos['x'] - 0.3
        self.goal.target_pose.pose.position.y = pos['y'] - 0.3
        self.goal.target_pose.pose.position.z = 0
        self.goal.target_pose.pose.orientation.x = ori['x']
        self.goal.target_pose.pose.orientation.y = ori['y']
        self.goal.target_pose.pose.orientation.z = ori['z']
        self.goal.target_pose.pose.orientation.w = ori['w']

    def move_to_goal(self):
        """
        move to self.goals[self.currentGoalId],
        """
        # define a client for to send goal requests to the move_base server through a SimpleActionClient
        client = actionlib.SimpleActionClient("/follower/move_base", MoveBaseAction)

        # wait for the action server to come up, wait for 10 sec or stop
        result = client.wait_for_server()
        rospy.loginfo("Result for wait_for_server is {r}".format(r=result))
        # while (not client.wait_for_server(rospy.Duration.from_sec(5.0))):
        #     rospy.loginfo("Waiting for the move_base action server to come up")

        rospy.loginfo("Sending goal location ...")
        print("goal: ", self.goal.target_pose.pose.position, self.goal.target_pose.pose.orientation)
        client.send_goal(self.goal)

        # client.wait_for_result(rospy.Duration(60))
        client.wait_for_result()
        if client.get_state() == GoalStatus.SUCCEEDED:
            rospy.loginfo("You have reached the destination")
            return True
        else:
            rospy.loginfo("The robot failed to reach the destination")
            return False

    def run(self):
        rospy.loginfo("Fiducial Broadcaster started")

        marker_frame = False
        while not rospy.is_shutdown():
            if not marker_frame:
                self.publishTransform()
                rospy.sleep(10)
                marker_frame = True
            #self.publishTransform()
            #self.rate.sleep()
            # self.check_transform()
            # print("Marker data:", self.get_marker_data())
        self.close()
        rospy.loginfo("Fiducial Broadcaster ended")



        # # parent frame for the listener
        # parent_frame = "/map"  # it should be /map But in my frames.pdf it currently doesn't have map
        # # child frame for the listener
        # child_frame = '/marker_frame'
        #
        # try:
        #     # listener to get child_frame vs parent_frame
        #     relative_pose_tf = TransformStamped()
        #     t = self.tf_listener.getLatestCommonTime(child_frame, parent_frame)
        #     (trans, rot) = self.tf_listener.lookupTransform(child_frame, parent_frame, t)
        #     print("In get marker data, trans, rot", trans, rot)
        #     # rotation is a list [r, p, y]
        #     point = Point(*trans)
        #     rotation = euler_from_quaternion(rot)
        #     print("point:",point, "rotation:", rotation)
        #
        #
        # except (tf.Exception, tf.ConnectivityException, tf.LookupException):
        #     rospy.loginfo("TF Exception")
        #     return
        #
        # # return the position (x, y, z) and the yaw
        # return point, rotation

if __name__ == '__main__':
    node = FiducialBroadcast()
    node.run()
